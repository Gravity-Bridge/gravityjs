// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file gravity/v1/genesis.proto (package gravity.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../cosmos/base/coin";
import { ERC20ToDenom, PendingIbcAutoForward, Valset } from "./types_pb.js";
import { MsgConfirmBatch, MsgConfirmLogicCall, MsgSetOrchestratorAddress, MsgValsetConfirm } from "./msgs_pb.js";
import { OutgoingLogicCall, OutgoingTransferTx, OutgoingTxBatch } from "./batch_pb.js";
import { Attestation } from "./attestation_pb.js";

/**
 * The slashing fractions for the various gravity related slashing conditions. The first three
 * refer to not submitting a particular message, the third for submitting a different claim
 * for the same Ethereum event
 *
 * unbond_slashing_valsets_window
 *
 * The unbond slashing valsets window is used to determine how many blocks after starting to unbond
 * a validator needs to continue signing blocks. The goal of this paramater is that when a validator leaves
 * the set, if their leaving creates enough change in the validator set to justify an update they will sign
 * a validator set update for the Ethereum bridge that does not include themselves. Allowing us to remove them
 * from the Ethereum bridge and replace them with the new set gracefully.
 *
 * valset_reward
 *
 * These parameters allow for the bridge oracle to resolve a fork on the Ethereum chain without halting
 * the chain. Once set reset bridge state will roll back events to the nonce provided in reset_bridge_nonce
 * if and only if those events have not yet been observed (executed on the Cosmos chain). This allows for easy
 * handling of cases where for example an Ethereum hardfork has occured and more than 1/3 of the vlaidtor set
 * disagrees with the rest. Normally this would require a chain halt, manual genesis editing and restar to resolve
 * with this feature a governance proposal can be used instead
 *
 * bridge_active
 *
 * This boolean flag can be used by governance to temporarily halt the bridge due to a vulnerability or other issue
 * In this context halting the bridge means prevent the execution of any oracle events from Ethereum and preventing
 * the creation of new batches that may be relayed to Ethereum.
 * This does not prevent the creation of validator sets
 * or slashing for not submitting validator set signatures as either of these might allow key signers to leave the validator
 * set and steal funds on Ethereum without consequence.
 * The practical outcome of this flag being set to 'false' is that deposits from Ethereum will not show up and withdraws from
 * Cosmos will not execute on Ethereum.
 *
 * min_chain_fee_basis_points
 *
 * The minimum SendToEth `chain_fee` amount, in terms of basis points. e.g. 10% fee = 1000, and 0.02% fee = 2
 *
 * chain_fee_auction_pool_fraction
 *
 * Specifies what fraction of the SendToEth `chain_fee` amount should go to the auction pool.
 * e.g. "0.5" gives a 50% auction pool / staker split while "0.9" would cause 90% of the fee to go to the pool
 *
 * @generated from message gravity.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * @generated from field: string gravity_id = 1;
   */
  gravityId = "";

  /**
   * @generated from field: string contract_source_hash = 2;
   */
  contractSourceHash = "";

  /**
   * @generated from field: string bridge_ethereum_address = 4;
   */
  bridgeEthereumAddress = "";

  /**
   * @generated from field: uint64 bridge_chain_id = 5;
   */
  bridgeChainId = protoInt64.zero;

  /**
   * @generated from field: uint64 signed_valsets_window = 6;
   */
  signedValsetsWindow = protoInt64.zero;

  /**
   * @generated from field: uint64 signed_batches_window = 7;
   */
  signedBatchesWindow = protoInt64.zero;

  /**
   * @generated from field: uint64 signed_logic_calls_window = 8;
   */
  signedLogicCallsWindow = protoInt64.zero;

  /**
   * @generated from field: uint64 target_batch_timeout = 9;
   */
  targetBatchTimeout = protoInt64.zero;

  /**
   * @generated from field: uint64 average_block_time = 10;
   */
  averageBlockTime = protoInt64.zero;

  /**
   * @generated from field: uint64 average_ethereum_block_time = 11;
   */
  averageEthereumBlockTime = protoInt64.zero;

  /**
   * @generated from field: bytes slash_fraction_valset = 12;
   */
  slashFractionValset = new Uint8Array(0);

  /**
   * @generated from field: bytes slash_fraction_batch = 13;
   */
  slashFractionBatch = new Uint8Array(0);

  /**
   * @generated from field: bytes slash_fraction_logic_call = 14;
   */
  slashFractionLogicCall = new Uint8Array(0);

  /**
   * @generated from field: uint64 unbond_slashing_valsets_window = 15;
   */
  unbondSlashingValsetsWindow = protoInt64.zero;

  /**
   * @generated from field: bytes slash_fraction_bad_eth_signature = 16;
   */
  slashFractionBadEthSignature = new Uint8Array(0);

  /**
   * @generated from field: cosmos.base.v1beta1.Coin valset_reward = 17;
   */
  valsetReward?: Coin;

  /**
   * @generated from field: bool bridge_active = 18;
   */
  bridgeActive = false;

  /**
   * addresses on this blacklist are forbidden from depositing or withdrawing
   * from Ethereum to the bridge
   *
   * @generated from field: repeated string ethereum_blacklist = 19;
   */
  ethereumBlacklist: string[] = [];

  /**
   * @generated from field: uint64 min_chain_fee_basis_points = 20;
   */
  minChainFeeBasisPoints = protoInt64.zero;

  /**
   * @generated from field: string chain_fee_auction_pool_fraction = 21;
   */
  chainFeeAuctionPoolFraction = "";

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gravity_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contract_source_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "bridge_ethereum_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "bridge_chain_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "signed_valsets_window", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "signed_batches_window", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "signed_logic_calls_window", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "target_batch_timeout", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "average_block_time", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "average_ethereum_block_time", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "slash_fraction_valset", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 13, name: "slash_fraction_batch", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 14, name: "slash_fraction_logic_call", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 15, name: "unbond_slashing_valsets_window", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 16, name: "slash_fraction_bad_eth_signature", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 17, name: "valset_reward", kind: "message", T: Coin },
    { no: 18, name: "bridge_active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "ethereum_blacklist", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 20, name: "min_chain_fee_basis_points", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 21, name: "chain_fee_auction_pool_fraction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * GenesisState struct, containing all persistant data required by the Gravity module
 *
 * @generated from message gravity.v1.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * @generated from field: gravity.v1.Params params = 1;
   */
  params?: Params;

  /**
   * @generated from field: gravity.v1.GravityNonces gravity_nonces = 2;
   */
  gravityNonces?: GravityNonces;

  /**
   * @generated from field: repeated gravity.v1.Valset valsets = 3;
   */
  valsets: Valset[] = [];

  /**
   * @generated from field: repeated gravity.v1.MsgValsetConfirm valset_confirms = 4;
   */
  valsetConfirms: MsgValsetConfirm[] = [];

  /**
   * @generated from field: repeated gravity.v1.OutgoingTxBatch batches = 5;
   */
  batches: OutgoingTxBatch[] = [];

  /**
   * @generated from field: repeated gravity.v1.MsgConfirmBatch batch_confirms = 6;
   */
  batchConfirms: MsgConfirmBatch[] = [];

  /**
   * @generated from field: repeated gravity.v1.OutgoingLogicCall logic_calls = 7;
   */
  logicCalls: OutgoingLogicCall[] = [];

  /**
   * @generated from field: repeated gravity.v1.MsgConfirmLogicCall logic_call_confirms = 8;
   */
  logicCallConfirms: MsgConfirmLogicCall[] = [];

  /**
   * @generated from field: repeated gravity.v1.Attestation attestations = 9;
   */
  attestations: Attestation[] = [];

  /**
   * @generated from field: repeated gravity.v1.MsgSetOrchestratorAddress delegate_keys = 10;
   */
  delegateKeys: MsgSetOrchestratorAddress[] = [];

  /**
   * @generated from field: repeated gravity.v1.ERC20ToDenom erc20_to_denoms = 11;
   */
  erc20ToDenoms: ERC20ToDenom[] = [];

  /**
   * @generated from field: repeated gravity.v1.OutgoingTransferTx unbatched_transfers = 12;
   */
  unbatchedTransfers: OutgoingTransferTx[] = [];

  /**
   * @generated from field: repeated gravity.v1.PendingIbcAutoForward pending_ibc_auto_forwards = 13;
   */
  pendingIbcAutoForwards: PendingIbcAutoForward[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "gravity_nonces", kind: "message", T: GravityNonces },
    { no: 3, name: "valsets", kind: "message", T: Valset, repeated: true },
    { no: 4, name: "valset_confirms", kind: "message", T: MsgValsetConfirm, repeated: true },
    { no: 5, name: "batches", kind: "message", T: OutgoingTxBatch, repeated: true },
    { no: 6, name: "batch_confirms", kind: "message", T: MsgConfirmBatch, repeated: true },
    { no: 7, name: "logic_calls", kind: "message", T: OutgoingLogicCall, repeated: true },
    { no: 8, name: "logic_call_confirms", kind: "message", T: MsgConfirmLogicCall, repeated: true },
    { no: 9, name: "attestations", kind: "message", T: Attestation, repeated: true },
    { no: 10, name: "delegate_keys", kind: "message", T: MsgSetOrchestratorAddress, repeated: true },
    { no: 11, name: "erc20_to_denoms", kind: "message", T: ERC20ToDenom, repeated: true },
    { no: 12, name: "unbatched_transfers", kind: "message", T: OutgoingTransferTx, repeated: true },
    { no: 13, name: "pending_ibc_auto_forwards", kind: "message", T: PendingIbcAutoForward, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * GravityCounters contains the many noces and counters required to maintain the bridge state in the genesis
 *
 * @generated from message gravity.v1.GravityNonces
 */
export class GravityNonces extends Message<GravityNonces> {
  /**
   * the nonce of the last generated validator set
   *
   * @generated from field: uint64 latest_valset_nonce = 1;
   */
  latestValsetNonce = protoInt64.zero;

  /**
   * the last observed Gravity.sol contract event nonce
   *
   * @generated from field: uint64 last_observed_nonce = 2;
   */
  lastObservedNonce = protoInt64.zero;

  /**
   * the last valset nonce we have slashed, to prevent double slashing
   *
   * @generated from field: uint64 last_slashed_valset_nonce = 3;
   */
  lastSlashedValsetNonce = protoInt64.zero;

  /**
   * the last batch Cosmos chain block that batch slashing has completed for
   * there is an individual batch nonce for each token type so this removes
   * the need to store them all
   *
   * @generated from field: uint64 last_slashed_batch_block = 4;
   */
  lastSlashedBatchBlock = protoInt64.zero;

  /**
   * the last cosmos block that logic call slashing has completed for
   *
   * @generated from field: uint64 last_slashed_logic_call_block = 5;
   */
  lastSlashedLogicCallBlock = protoInt64.zero;

  /**
   * the last transaction id from the Gravity TX pool, this prevents ID
   * duplication during chain upgrades
   *
   * @generated from field: uint64 last_tx_pool_id = 6;
   */
  lastTxPoolId = protoInt64.zero;

  /**
   * the last batch id from the Gravity batch pool, this prevents ID duplication
   * during chain upgrades
   *
   * @generated from field: uint64 last_batch_id = 7;
   */
  lastBatchId = protoInt64.zero;

  constructor(data?: PartialMessage<GravityNonces>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.GravityNonces";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "latest_valset_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "last_observed_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "last_slashed_valset_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "last_slashed_batch_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "last_slashed_logic_call_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "last_tx_pool_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "last_batch_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GravityNonces {
    return new GravityNonces().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GravityNonces {
    return new GravityNonces().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GravityNonces {
    return new GravityNonces().fromJsonString(jsonString, options);
  }

  static equals(a: GravityNonces | PlainMessage<GravityNonces> | undefined, b: GravityNonces | PlainMessage<GravityNonces> | undefined): boolean {
    return proto3.util.equals(GravityNonces, a, b);
  }
}
