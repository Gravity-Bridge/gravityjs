// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file gravity/v1/attestation.proto (package gravity.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * ClaimType is the cosmos type of an event from the counterpart chain that can
 * be handled
 *
 * @generated from enum gravity.v1.ClaimType
 */
export enum ClaimType {
  /**
   * An unspecified claim type
   *
   * @generated from enum value: CLAIM_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * A claim for a SendToCosmos transaction
   *
   * @generated from enum value: CLAIM_TYPE_SEND_TO_COSMOS = 1;
   */
  SEND_TO_COSMOS = 1,

  /**
   * A claim for when batches are relayed
   *
   * @generated from enum value: CLAIM_TYPE_BATCH_SEND_TO_ETH = 2;
   */
  BATCH_SEND_TO_ETH = 2,

  /**
   * A claim for when an erc20 contract has been deployed
   *
   * @generated from enum value: CLAIM_TYPE_ERC20_DEPLOYED = 3;
   */
  ERC20_DEPLOYED = 3,

  /**
   * A claim for when a logic call has been executed
   *
   * @generated from enum value: CLAIM_TYPE_LOGIC_CALL_EXECUTED = 4;
   */
  LOGIC_CALL_EXECUTED = 4,

  /**
   * A claim for when a valset update has happened
   *
   * @generated from enum value: CLAIM_TYPE_VALSET_UPDATED = 5;
   */
  VALSET_UPDATED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ClaimType)
proto3.util.setEnumType(ClaimType, "gravity.v1.ClaimType", [
  { no: 0, name: "CLAIM_TYPE_UNSPECIFIED" },
  { no: 1, name: "CLAIM_TYPE_SEND_TO_COSMOS" },
  { no: 2, name: "CLAIM_TYPE_BATCH_SEND_TO_ETH" },
  { no: 3, name: "CLAIM_TYPE_ERC20_DEPLOYED" },
  { no: 4, name: "CLAIM_TYPE_LOGIC_CALL_EXECUTED" },
  { no: 5, name: "CLAIM_TYPE_VALSET_UPDATED" },
]);

/**
 * Attestation is an aggregate of `claims` that eventually becomes `observed` by
 * all orchestrators
 * EVENT_NONCE:
 * EventNonce a nonce provided by the gravity contract that is unique per event fired
 * These event nonces must be relayed in order. This is a correctness issue,
 * if relaying out of order transaction replay attacks become possible
 * OBSERVED:
 * Observed indicates that >67% of validators have attested to the event,
 * and that the event should be executed by the gravity state machine
 *
 * The actual content of the claims is passed in with the transaction making the claim
 * and then passed through the call stack alongside the attestation while it is processed
 * the key in which the attestation is stored is keyed on the exact details of the claim
 * but there is no reason to store those exact details becuause the next message sender
 * will kindly provide you with them.
 *
 * @generated from message gravity.v1.Attestation
 */
export class Attestation extends Message<Attestation> {
  /**
   * @generated from field: bool observed = 1;
   */
  observed = false;

  /**
   * @generated from field: repeated string votes = 2;
   */
  votes: string[] = [];

  /**
   * @generated from field: uint64 height = 3;
   */
  height = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Any claim = 4;
   */
  claim?: Any;

  constructor(data?: PartialMessage<Attestation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.Attestation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "observed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "votes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "claim", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Attestation {
    return new Attestation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Attestation {
    return new Attestation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Attestation {
    return new Attestation().fromJsonString(jsonString, options);
  }

  static equals(a: Attestation | PlainMessage<Attestation> | undefined, b: Attestation | PlainMessage<Attestation> | undefined): boolean {
    return proto3.util.equals(Attestation, a, b);
  }
}

/**
 * ERC20Token unique identifier for an Ethereum ERC20 token.
 * CONTRACT:
 * The contract address on ETH of the token, this could be a Cosmos
 * originated token, if so it will be the ERC20 address of the representation
 * (note: developers should look up the token symbol using the address on ETH to display for UI)
 *
 * @generated from message gravity.v1.ERC20Token
 */
export class ERC20Token extends Message<ERC20Token> {
  /**
   * @generated from field: string contract = 1;
   */
  contract = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<ERC20Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.ERC20Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contract", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ERC20Token {
    return new ERC20Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ERC20Token {
    return new ERC20Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ERC20Token {
    return new ERC20Token().fromJsonString(jsonString, options);
  }

  static equals(a: ERC20Token | PlainMessage<ERC20Token> | undefined, b: ERC20Token | PlainMessage<ERC20Token> | undefined): boolean {
    return proto3.util.equals(ERC20Token, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventObservation
 */
export class EventObservation extends Message<EventObservation> {
  /**
   * @generated from field: string attestation_type = 1;
   */
  attestationType = "";

  /**
   * @generated from field: string bridge_contract = 2;
   */
  bridgeContract = "";

  /**
   * @generated from field: string bridge_chain_id = 3;
   */
  bridgeChainId = "";

  /**
   * @generated from field: string attestation_id = 4;
   */
  attestationId = "";

  /**
   * @generated from field: string nonce = 5;
   */
  nonce = "";

  constructor(data?: PartialMessage<EventObservation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventObservation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "attestation_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bridge_contract", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "bridge_chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "attestation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventObservation {
    return new EventObservation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventObservation {
    return new EventObservation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventObservation {
    return new EventObservation().fromJsonString(jsonString, options);
  }

  static equals(a: EventObservation | PlainMessage<EventObservation> | undefined, b: EventObservation | PlainMessage<EventObservation> | undefined): boolean {
    return proto3.util.equals(EventObservation, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventInvalidSendToCosmosReceiver
 */
export class EventInvalidSendToCosmosReceiver extends Message<EventInvalidSendToCosmosReceiver> {
  /**
   * @generated from field: string amount = 1;
   */
  amount = "";

  /**
   * @generated from field: string nonce = 2;
   */
  nonce = "";

  /**
   * @generated from field: string token = 3;
   */
  token = "";

  /**
   * @generated from field: string sender = 4;
   */
  sender = "";

  constructor(data?: PartialMessage<EventInvalidSendToCosmosReceiver>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventInvalidSendToCosmosReceiver";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventInvalidSendToCosmosReceiver {
    return new EventInvalidSendToCosmosReceiver().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventInvalidSendToCosmosReceiver {
    return new EventInvalidSendToCosmosReceiver().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventInvalidSendToCosmosReceiver {
    return new EventInvalidSendToCosmosReceiver().fromJsonString(jsonString, options);
  }

  static equals(a: EventInvalidSendToCosmosReceiver | PlainMessage<EventInvalidSendToCosmosReceiver> | undefined, b: EventInvalidSendToCosmosReceiver | PlainMessage<EventInvalidSendToCosmosReceiver> | undefined): boolean {
    return proto3.util.equals(EventInvalidSendToCosmosReceiver, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventSendToCosmos
 */
export class EventSendToCosmos extends Message<EventSendToCosmos> {
  /**
   * @generated from field: string amount = 1;
   */
  amount = "";

  /**
   * @generated from field: string nonce = 2;
   */
  nonce = "";

  /**
   * @generated from field: string token = 3;
   */
  token = "";

  constructor(data?: PartialMessage<EventSendToCosmos>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventSendToCosmos";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSendToCosmos {
    return new EventSendToCosmos().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSendToCosmos {
    return new EventSendToCosmos().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSendToCosmos {
    return new EventSendToCosmos().fromJsonString(jsonString, options);
  }

  static equals(a: EventSendToCosmos | PlainMessage<EventSendToCosmos> | undefined, b: EventSendToCosmos | PlainMessage<EventSendToCosmos> | undefined): boolean {
    return proto3.util.equals(EventSendToCosmos, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventSendToCosmosLocal
 */
export class EventSendToCosmosLocal extends Message<EventSendToCosmosLocal> {
  /**
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  /**
   * @generated from field: string token = 3;
   */
  token = "";

  /**
   * @generated from field: string amount = 4;
   */
  amount = "";

  constructor(data?: PartialMessage<EventSendToCosmosLocal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventSendToCosmosLocal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSendToCosmosLocal {
    return new EventSendToCosmosLocal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSendToCosmosLocal {
    return new EventSendToCosmosLocal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSendToCosmosLocal {
    return new EventSendToCosmosLocal().fromJsonString(jsonString, options);
  }

  static equals(a: EventSendToCosmosLocal | PlainMessage<EventSendToCosmosLocal> | undefined, b: EventSendToCosmosLocal | PlainMessage<EventSendToCosmosLocal> | undefined): boolean {
    return proto3.util.equals(EventSendToCosmosLocal, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventSendToCosmosPendingIbcAutoForward
 */
export class EventSendToCosmosPendingIbcAutoForward extends Message<EventSendToCosmosPendingIbcAutoForward> {
  /**
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  /**
   * @generated from field: string token = 3;
   */
  token = "";

  /**
   * @generated from field: string amount = 4;
   */
  amount = "";

  /**
   * @generated from field: string channel = 5;
   */
  channel = "";

  constructor(data?: PartialMessage<EventSendToCosmosPendingIbcAutoForward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventSendToCosmosPendingIbcAutoForward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSendToCosmosPendingIbcAutoForward {
    return new EventSendToCosmosPendingIbcAutoForward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSendToCosmosPendingIbcAutoForward {
    return new EventSendToCosmosPendingIbcAutoForward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSendToCosmosPendingIbcAutoForward {
    return new EventSendToCosmosPendingIbcAutoForward().fromJsonString(jsonString, options);
  }

  static equals(a: EventSendToCosmosPendingIbcAutoForward | PlainMessage<EventSendToCosmosPendingIbcAutoForward> | undefined, b: EventSendToCosmosPendingIbcAutoForward | PlainMessage<EventSendToCosmosPendingIbcAutoForward> | undefined): boolean {
    return proto3.util.equals(EventSendToCosmosPendingIbcAutoForward, a, b);
  }
}

/**
 * @generated from message gravity.v1.EventSendToCosmosExecutedIbcAutoForward
 */
export class EventSendToCosmosExecutedIbcAutoForward extends Message<EventSendToCosmosExecutedIbcAutoForward> {
  /**
   * @generated from field: string nonce = 1;
   */
  nonce = "";

  /**
   * @generated from field: string receiver = 2;
   */
  receiver = "";

  /**
   * @generated from field: string token = 3;
   */
  token = "";

  /**
   * @generated from field: string amount = 4;
   */
  amount = "";

  /**
   * @generated from field: string channel = 5;
   */
  channel = "";

  /**
   * @generated from field: string timeout_time = 6;
   */
  timeoutTime = "";

  /**
   * @generated from field: string timeout_height = 7;
   */
  timeoutHeight = "";

  constructor(data?: PartialMessage<EventSendToCosmosExecutedIbcAutoForward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.EventSendToCosmosExecutedIbcAutoForward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "timeout_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "timeout_height", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSendToCosmosExecutedIbcAutoForward {
    return new EventSendToCosmosExecutedIbcAutoForward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSendToCosmosExecutedIbcAutoForward {
    return new EventSendToCosmosExecutedIbcAutoForward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSendToCosmosExecutedIbcAutoForward {
    return new EventSendToCosmosExecutedIbcAutoForward().fromJsonString(jsonString, options);
  }

  static equals(a: EventSendToCosmosExecutedIbcAutoForward | PlainMessage<EventSendToCosmosExecutedIbcAutoForward> | undefined, b: EventSendToCosmosExecutedIbcAutoForward | PlainMessage<EventSendToCosmosExecutedIbcAutoForward> | undefined): boolean {
    return proto3.util.equals(EventSendToCosmosExecutedIbcAutoForward, a, b);
  }
}

