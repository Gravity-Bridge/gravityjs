// @generated by protoc-gen-es v1.4.2 with parameter "target=ts"
// @generated from file gravity/v1/types.proto (package gravity.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Metadata } from "../../cosmos/bank/v1beta1/bank_pb.js";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * BridgeValidator represents a validator's ETH address and its power
 *
 * @generated from message gravity.v1.BridgeValidator
 */
export class BridgeValidator extends Message<BridgeValidator> {
  /**
   * @generated from field: uint64 power = 1;
   */
  power = protoInt64.zero;

  /**
   * @generated from field: string ethereum_address = 2;
   */
  ethereumAddress = "";

  constructor(data?: PartialMessage<BridgeValidator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.BridgeValidator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "power", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ethereum_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BridgeValidator {
    return new BridgeValidator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BridgeValidator {
    return new BridgeValidator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BridgeValidator {
    return new BridgeValidator().fromJsonString(jsonString, options);
  }

  static equals(a: BridgeValidator | PlainMessage<BridgeValidator> | undefined, b: BridgeValidator | PlainMessage<BridgeValidator> | undefined): boolean {
    return proto3.util.equals(BridgeValidator, a, b);
  }
}

/**
 * Valset is the Ethereum Bridge Multsig Set, each gravity validator also
 * maintains an ETH key to sign messages, these are used to check signatures on
 * ETH because of the significant gas savings
 *
 * @generated from message gravity.v1.Valset
 */
export class Valset extends Message<Valset> {
  /**
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * @generated from field: repeated gravity.v1.BridgeValidator members = 2;
   */
  members: BridgeValidator[] = [];

  /**
   * @generated from field: uint64 height = 3;
   */
  height = protoInt64.zero;

  /**
   * @generated from field: string reward_amount = 4;
   */
  rewardAmount = "";

  /**
   * the reward token in it's Ethereum hex address representation
   *
   * @generated from field: string reward_token = 5;
   */
  rewardToken = "";

  constructor(data?: PartialMessage<Valset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.Valset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "members", kind: "message", T: BridgeValidator, repeated: true },
    { no: 3, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "reward_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "reward_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Valset {
    return new Valset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Valset {
    return new Valset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Valset {
    return new Valset().fromJsonString(jsonString, options);
  }

  static equals(a: Valset | PlainMessage<Valset> | undefined, b: Valset | PlainMessage<Valset> | undefined): boolean {
    return proto3.util.equals(Valset, a, b);
  }
}

/**
 * LastObservedEthereumBlockHeight stores the last observed
 * Ethereum block height along with the Cosmos block height that
 * it was observed at. These two numbers can be used to project
 * outward and always produce batches with timeouts in the future
 * even if no Ethereum block height has been relayed for a long time
 *
 * @generated from message gravity.v1.LastObservedEthereumBlockHeight
 */
export class LastObservedEthereumBlockHeight extends Message<LastObservedEthereumBlockHeight> {
  /**
   * @generated from field: uint64 cosmos_block_height = 1;
   */
  cosmosBlockHeight = protoInt64.zero;

  /**
   * @generated from field: uint64 ethereum_block_height = 2;
   */
  ethereumBlockHeight = protoInt64.zero;

  constructor(data?: PartialMessage<LastObservedEthereumBlockHeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.LastObservedEthereumBlockHeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cosmos_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ethereum_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LastObservedEthereumBlockHeight {
    return new LastObservedEthereumBlockHeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LastObservedEthereumBlockHeight {
    return new LastObservedEthereumBlockHeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LastObservedEthereumBlockHeight {
    return new LastObservedEthereumBlockHeight().fromJsonString(jsonString, options);
  }

  static equals(a: LastObservedEthereumBlockHeight | PlainMessage<LastObservedEthereumBlockHeight> | undefined, b: LastObservedEthereumBlockHeight | PlainMessage<LastObservedEthereumBlockHeight> | undefined): boolean {
    return proto3.util.equals(LastObservedEthereumBlockHeight, a, b);
  }
}

/**
 * This records the relationship between an ERC20 token and the denom
 * of the corresponding Cosmos originated asset
 *
 * @generated from message gravity.v1.ERC20ToDenom
 */
export class ERC20ToDenom extends Message<ERC20ToDenom> {
  /**
   * @generated from field: string erc20 = 1;
   */
  erc20 = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  constructor(data?: PartialMessage<ERC20ToDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.ERC20ToDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "erc20", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ERC20ToDenom {
    return new ERC20ToDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ERC20ToDenom {
    return new ERC20ToDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ERC20ToDenom {
    return new ERC20ToDenom().fromJsonString(jsonString, options);
  }

  static equals(a: ERC20ToDenom | PlainMessage<ERC20ToDenom> | undefined, b: ERC20ToDenom | PlainMessage<ERC20ToDenom> | undefined): boolean {
    return proto3.util.equals(ERC20ToDenom, a, b);
  }
}

/**
 * UnhaltBridgeProposal defines a custom governance proposal useful for restoring
 * the bridge after a oracle disagreement. Once this proposal is passed bridge state will roll back events 
 * to the nonce provided in target_nonce if and only if those events have not yet been observed (executed on the Cosmos chain). This allows for easy
 * handling of cases where for example an Ethereum hardfork has occured and more than 1/3 of the vlaidtor set
 * disagrees with the rest. Normally this would require a chain halt, manual genesis editing and restar to resolve
 * with this feature a governance proposal can be used instead
 *
 * @generated from message gravity.v1.UnhaltBridgeProposal
 */
export class UnhaltBridgeProposal extends Message<UnhaltBridgeProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: uint64 target_nonce = 4;
   */
  targetNonce = protoInt64.zero;

  constructor(data?: PartialMessage<UnhaltBridgeProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.UnhaltBridgeProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "target_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnhaltBridgeProposal {
    return new UnhaltBridgeProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnhaltBridgeProposal {
    return new UnhaltBridgeProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnhaltBridgeProposal {
    return new UnhaltBridgeProposal().fromJsonString(jsonString, options);
  }

  static equals(a: UnhaltBridgeProposal | PlainMessage<UnhaltBridgeProposal> | undefined, b: UnhaltBridgeProposal | PlainMessage<UnhaltBridgeProposal> | undefined): boolean {
    return proto3.util.equals(UnhaltBridgeProposal, a, b);
  }
}

/**
 * AirdropProposal defines a custom governance proposal type that allows an airdrop to occur in a decentralized
 * fashion. A list of destination addresses and an amount per airdrop recipient is provided. The funds for this
 * airdrop are removed from the Community Pool, if the community pool does not have sufficient funding to perform
 * the airdrop to all provided recipients nothing will occur
 *
 * @generated from message gravity.v1.AirdropProposal
 */
export class AirdropProposal extends Message<AirdropProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: string denom = 3;
   */
  denom = "";

  /**
   * @generated from field: bytes recipients = 4;
   */
  recipients = new Uint8Array(0);

  /**
   * @generated from field: repeated uint64 amounts = 5;
   */
  amounts: bigint[] = [];

  constructor(data?: PartialMessage<AirdropProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.AirdropProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "recipients", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "amounts", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropProposal {
    return new AirdropProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropProposal {
    return new AirdropProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropProposal {
    return new AirdropProposal().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropProposal | PlainMessage<AirdropProposal> | undefined, b: AirdropProposal | PlainMessage<AirdropProposal> | undefined): boolean {
    return proto3.util.equals(AirdropProposal, a, b);
  }
}

/**
 * IBCMetadataProposal defines a custom governance proposal type that allows governance to set the
 * metadata for an IBC token, this will allow Gravity to deploy an ERC20 representing this token on
 * Ethereum
 * Name: the token name
 * Symbol: the token symbol
 * Description: the token description, not sent to ETH at all, only used on Cosmos
 * Display: the token display name (only used on Cosmos to decide ERC20 Decimals)
 * Deicmals: the decimals for the display unit
 * ibc_denom is the denom of the token in question on this chain
 *
 * @generated from message gravity.v1.IBCMetadataProposal
 */
export class IBCMetadataProposal extends Message<IBCMetadataProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: cosmos.bank.v1beta1.Metadata metadata = 3;
   */
  metadata?: Metadata;

  /**
   * @generated from field: string ibc_denom = 4;
   */
  ibcDenom = "";

  constructor(data?: PartialMessage<IBCMetadataProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.IBCMetadataProposal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
    { no: 4, name: "ibc_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IBCMetadataProposal {
    return new IBCMetadataProposal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IBCMetadataProposal {
    return new IBCMetadataProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IBCMetadataProposal {
    return new IBCMetadataProposal().fromJsonString(jsonString, options);
  }

  static equals(a: IBCMetadataProposal | PlainMessage<IBCMetadataProposal> | undefined, b: IBCMetadataProposal | PlainMessage<IBCMetadataProposal> | undefined): boolean {
    return proto3.util.equals(IBCMetadataProposal, a, b);
  }
}

/**
 * PendingIbcAutoForward represents a SendToCosmos transaction with a foreign CosmosReceiver which will be added to the
 * PendingIbcAutoForward queue in attestation_handler and sent over IBC on some submission of a MsgExecuteIbcAutoForwards
 *
 * @generated from message gravity.v1.PendingIbcAutoForward
 */
export class PendingIbcAutoForward extends Message<PendingIbcAutoForward> {
  /**
   * the destination address. sdk.AccAddress does not preserve foreign prefixes
   *
   * @generated from field: string foreign_receiver = 1;
   */
  foreignReceiver = "";

  /**
   * the token sent from ethereum to the ibc-enabled chain over `IbcChannel`
   *
   * @generated from field: cosmos.base.v1beta1.Coin token = 2;
   */
  token?: Coin;

  /**
   * the IBC channel to send `Amount` over via ibc-transfer module
   *
   * @generated from field: string ibc_channel = 3;
   */
  ibcChannel = "";

  /**
   * the EventNonce from the MsgSendToCosmosClaim, used for ordering the queue
   *
   * @generated from field: uint64 event_nonce = 4;
   */
  eventNonce = protoInt64.zero;

  constructor(data?: PartialMessage<PendingIbcAutoForward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gravity.v1.PendingIbcAutoForward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "foreign_receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token", kind: "message", T: Coin },
    { no: 3, name: "ibc_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "event_nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingIbcAutoForward {
    return new PendingIbcAutoForward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingIbcAutoForward {
    return new PendingIbcAutoForward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingIbcAutoForward {
    return new PendingIbcAutoForward().fromJsonString(jsonString, options);
  }

  static equals(a: PendingIbcAutoForward | PlainMessage<PendingIbcAutoForward> | undefined, b: PendingIbcAutoForward | PlainMessage<PendingIbcAutoForward> | undefined): boolean {
    return proto3.util.equals(PendingIbcAutoForward, a, b);
  }
}

